<section class="pane split-left">
  <div class="pane-body">
    <div class="chat">
      <div id="start-overlay" style="display:flex; align-items:center; justify-content:center; height: 200px; border:1px dashed var(--border); border-radius:12px; margin-bottom:12px">
        <button id="btn-start" type="button" class="btn" style="font-weight:600; padding:12px 18px">Start</button>
      </div>

      <div id="chat-help" style="margin-bottom:12px; color: var(--muted); font-size: 14px">
        <strong>How to use CRMBLR</strong>
        <div style="margin-top:6px">
          - Click Start to connect voice and tools.<br />
          - Type or speak your request (e.g., “find invoices from July”).<br />
          - The right panel shows tool calls and results.<br />
          - You can mute/unmute the mic anytime.
        </div>
      </div>

      <div id="chat-toolbar" style="display:none; align-items:center; gap:8px; margin-bottom:8px">
        <span id="audio-state" style="font-size:12px; color:var(--muted)">Muted</span>
        <button id="btn-mic-toggle" type="button" class="btn btn--secondary btn--sm">Unmute</button>
        <span id="voice-status" style="margin-left:auto; color: var(--muted); font-size:12px"></span>
      </div>

      <!-- Input fixed at the top of the chat; hidden until session starts -->
      <form id="chat-form" class="chat-input" onsubmit="return false" style="display:none">
        <input id="chat-input" type="text" placeholder="Type a message…" autocomplete="off" aria-label="Chat input" disabled />
        <button id="chat-send" type="button" disabled>Send</button>
      </form>

      <!-- Model-suggested Quick Actions (rendered as subtle chips) -->
      <div id="quick-actions" class="quick-actions" style="display:none; margin: 6px 0 10px; gap:6px; flex-wrap: wrap"></div>

      <!-- Newest messages appear at the top -->
      <ul id="chat-messages" class="chat-messages"></ul>

      <audio id="oai-audio" autoplay></audio>
    </div>
  </div>
</section>

<script>
  (function(){
    var list = document.getElementById('chat-messages');
    function addMessage(text, who, id){
      if (!list) return null;
      var li = document.createElement('li');
      li.className = 'chat-msg ' + (who || 'user');
      if (id) li.dataset.itemId = id;
      li.textContent = text;
      // Insert newest at the top
      if (list.firstChild) {
        list.insertBefore(li, list.firstChild);
      } else {
        list.appendChild(li);
      }
      return li;
    }
    window.__chatAddMessage = addMessage;
  })();
</script>

<script>
  (function(){
    var startOverlay = document.getElementById('start-overlay');
    var startBtn = document.getElementById('btn-start');
    var micToggle = document.getElementById('btn-mic-toggle');
    var audioState = document.getElementById('audio-state');
    var statusEl = document.getElementById('voice-status');
    var audioEl = document.getElementById('oai-audio');
    var pc = null; var dc = null; var ms = null; var sender = null;
    var inputEl = document.getElementById('chat-input');
    var sendBtn = document.getElementById('chat-send');
    var qaEl = document.getElementById('quick-actions');
    var token = localStorage.getItem('crmb_lr_jwt');
    if (!token){ window.location.href = '/login'; return; }

    var assistantItems = Object.create(null); // assistant item_id -> <li>
    var userItems = Object.create(null); // user item_id -> <li>
    var userText = Object.create(null); // user item_id -> transcript buffer

    function setStatus(t){ statusEl.textContent = t || ''; }

    function setMutedUI(isMuted){
      audioState.textContent = isMuted ? 'Muted' : 'Unmuted';
      micToggle.textContent = isMuted ? 'Unmute' : 'Mute';
    }
    // Legacy mic indicator hooks (no visible indicator in UI)
    function micOn(){ try { setMutedUI(false); } catch(_){} }
    function micOff(){ try { setMutedUI(true); } catch(_){} }

    const toolArgBuf = Object.create(null); // tool_call_id -> string buffer
    const toolMetaByItem = Object.create(null); // item_id -> { name, call_id }
    var lastAssistantId = null;

    function setQuickActions(actions){
      try {
        if (!qaEl) return;
        qaEl.innerHTML = '';
        if (!actions || !actions.length){ qaEl.style.display = 'none'; return; }
        actions.slice(0,4).forEach(function(text){
          var btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'btn btn--ghost btn--sm qa-chip';
          btn.textContent = text.length > 60 ? (text.slice(0,57) + '…') : text;
          btn.title = text;
          btn.addEventListener('click', function(){ sendPrompt(text); btn.disabled = true; setTimeout(function(){ btn.disabled = false; }, 600); });
          qaEl.appendChild(btn);
        });
        qaEl.style.display = 'flex';
      } catch(_){}
    }

    function parsePrompts(text){
      var out = [];
      try {
        var rx = /<<PROMPT:\s*(.*?)>>/g;
        var m;
        var seen = Object.create(null);
        while ((m = rx.exec(text))) {
          var s = (m[1] || '').trim();
          if (!s) continue;
          var key = s.toLowerCase();
          if (seen[key]) continue;
          seen[key] = true;
          out.push(s);
          if (out.length >= 4) break;
        }
      } catch(_){}
      return out;
    }

    function stripPrompts(text){
      try { return (text || '').replace(/<<PROMPT:[\s\S]*?>>/g, '').trim(); } catch(_) { return text; }
    }

    function humanTool(name){
      var map = {
        list_collections: 'List Collections',
        list_docs: 'List Documents',
        create_doc: 'Create Document',
        get_doc: 'Get Document',
        update_doc: 'Update Document',
        delete_doc: 'Delete Document'
      };
      if (!name) return 'Tool';
      return map[name] || String(name).replace(/_/g, ' ').replace(/\b\w/g, function(c){ return c.toUpperCase(); });
    }

    function registerTools(){
      if (!dc) return;
      const tools = [
        {
          type: "function",
          name: "list_collections",
          description: "List collection names for the current user",
          parameters: { type: "object", properties: {} }
        },
        {
          type: "function",
          name: "list_docs",
          description: "List documents in a collection",
          parameters: {
            type: "object",
            properties: {
              collection: { type: "string" },
              query: { type: "object" },
              size: { type: "integer", minimum: 1, default: 50 },
              from: { type: "integer", minimum: 0, default: 0 }
            },
            required: ["collection"],
            additionalProperties: true
          }
        },
        {
          type: "function",
          name: "create_doc",
          description: "Create a document in an Elasticsearch index",
          parameters: {
            type: "object",
            properties: {
              collection: { type: "string" },
              doc: { type: "object" }
            },
            required: ["collection", "doc"],
            additionalProperties: true
          }
        },
        {
          type: "function",
          name: "get_doc",
          description: "Get a document by id",
          parameters: {
            type: "object",
            properties: {
              collection: { type: "string" },
              id: { type: "string" }
            },
            required: ["collection", "id"]
          }
        },
        {
          type: "function",
          name: "update_doc",
          description: "Update a document by id (merge fields)",
          parameters: {
            type: "object",
            properties: {
              collection: { type: "string" },
              id: { type: "string" },
              doc: { type: "object" }
            },
            required: ["collection", "id", "doc"],
            additionalProperties: true
          }
        },
        {
          type: "function",
          name: "delete_doc",
          description: "Delete a document by id",
          parameters: {
            type: "object",
            properties: {
              collection: { type: "string" },
              id: { type: "string" }
            },
            required: ["collection", "id"]
          }
        }
      ];
      try {
        dc.send(JSON.stringify({ type: 'session.update', session: { tools, tool_choice: 'auto' } }));
      } catch (e) { console.warn('Failed to register tools', e); }
    }

    async function callBackendTool(name, args){
      // Log start
      try { window.__appendToolLog && window.__appendToolLog({ name, args, status: 'started' }); } catch(_){ }
      const r = await fetch('/tool', { method:'POST', headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token }, body: JSON.stringify({ name, arguments: args }) });
      const data = await r.json();
      if (!r.ok || !data.ok){ throw new Error(data.error || 'tool error'); }
      try { window.__appendToolLog && window.__appendToolLog({ name, args, status: 'ok', result: data.result }); } catch(_){ }
      return data.result;
    }

    function handleServerEvent(obj){
      console.log('Server event:', obj);
      switch (obj.type){
        case 'error': {
          try { window.__appendToolLog && window.__appendToolLog({ name: 'error', status: 'error', error: JSON.stringify(obj.error || obj) }); } catch(_){ }
          break;
        }
        case 'session.created':
          setStatus('Connected');
          break;
        case 'input_audio_buffer.speech_started': {
          var li = window.__chatAddMessage('Listening…', 'user');
          userItems[obj.item_id] = li;
          micOn();
          break;
        }
        case 'input_audio_buffer.speech_stopped': {
          var li2 = userItems[obj.item_id];
          if (li2){ li2.textContent = 'Audio received'; }
          micOff();
          break;
        }
        case 'input_audio_buffer.committed': {
          var lu = userItems[obj.item_id];
          if (lu){ lu.textContent = 'Audio received'; }
          micOff();
          break;
        }
        case 'input_audio_buffer.transcript.delta': {
          var current = userText[obj.item_id] || '';
          var d = obj.delta || obj.transcript || '';
          current += d;
          userText[obj.item_id] = current;
          var lu = userItems[obj.item_id] || window.__chatAddMessage('', 'user');
          userItems[obj.item_id] = lu;
          lu.textContent = current;
          break;
        }
        case 'input_audio_buffer.transcript.done': {
          if (obj.transcript){ userText[obj.item_id] = obj.transcript; }
          var lu2 = userItems[obj.item_id];
          if (lu2 && userText[obj.item_id]){ lu2.textContent = userText[obj.item_id]; }
          micOff();
          break;
        }
        case 'conversation.item.added': {
          var it = obj.item || {};
          if (it.role === 'user'){
            var id = it.id || obj.item_id;
            var lu3 = userItems[id] || window.__chatAddMessage('', 'user', id);
            userItems[id] = lu3;
            var t = userText[id];
            if (t && (!lu3.textContent || lu3.textContent === 'Listening…' || lu3.textContent === 'Audio received')){
              lu3.textContent = t;
            }
          } else if (it.role === 'assistant'){
            var aid = it.id || obj.item_id;
            var la = window.__chatAddMessage('', 'bot', aid);
            assistantItems[aid] = la;
            lastAssistantId = aid;
          }
          break;
        }
        case 'response.output_item.added': {
          var item = obj.item || {}; // sometimes included
          if (item.type === 'function_call'){
            toolMetaByItem[item.id] = { name: item.name, call_id: item.call_id };
            try { window.__appendToolLog && window.__appendToolLog({ name: item.name || 'function', status: 'started', args: {} }); } catch(_){ }
          } else {
            var id = (item && item.id) || obj.item_id;
            var li3 = window.__chatAddMessage('', 'bot', id);
            assistantItems[id] = li3;
          }
          break;
        }
        case 'response.output_audio_transcript.delta': {
          var t = obj.delta || obj.transcript || '';
          var target = assistantItems[obj.item_id];
          if (target){ target.textContent += t; lastAssistantId = obj.item_id; }
          break;
        }
        case 'response.output_audio_transcript.done': {
          var target2 = assistantItems[obj.item_id];
          if (target2 && obj.transcript){ target2.textContent = obj.transcript; lastAssistantId = obj.item_id; }
          break;
        }
        case 'response.content_part.done': {
          var p = obj.part || {};
          if (p && p.transcript){
            var target3 = assistantItems[obj.item_id] || window.__chatAddMessage('', 'bot', obj.item_id);
            target3.textContent = p.transcript;
            assistantItems[obj.item_id] = target3;
            lastAssistantId = obj.item_id;
          }
          break;
        }
        case 'response.done':
          try {
            if (lastAssistantId){
              var el = assistantItems[lastAssistantId];
              if (el){
                var raw = el.textContent || '';
                var actions = parsePrompts(raw);
                var clean = stripPrompts(raw);
                el.textContent = clean;
                setQuickActions(actions);
              }
            }
          } catch(_){ }
          setStatus('Ready');
          break;
        // Tool calling (collect args, then execute)
        case 'response.function_call_arguments.delta': {
          const id = obj.item_id || obj.id || obj.call_id || 'default';
          const chunk = obj.delta || obj.arguments || '';
          toolArgBuf[id] = (toolArgBuf[id] || '') + chunk;
          break;
        }
        case 'response.function_call_arguments.done': {
          try {
            const id = obj.item_id || obj.id || obj.call_id || 'default';
            const meta = toolMetaByItem[id] || {};
            const name = meta.name || obj.name || obj.tool_name;
            const callId = meta.call_id || obj.call_id;
            const argsStr = toolArgBuf[id] || obj.arguments || '{}';
            const args = JSON.parse(argsStr || '{}');
            callBackendTool(name, args)
              .then(result => {
                // Hint only in chat instead of dumping full JSON
                var label = humanTool(name);
                var hint = `Ran ${label}`;
                try {
                  if (name === 'list_docs'){
                    var total = (result && result.hits && result.hits.total && (result.hits.total.value || result.hits.total)) || 0;
                    hint = `${label}: ${total} result${Number(total) === 1 ? '' : 's'}`;
                  } else if (name === 'list_collections'){
                    var cols = (result && result.collections) || [];
                    hint = `${label}: ${cols.length} found`;
                  }
                } catch(_){ }
                window.__chatAddMessage(hint, 'user');
                // Feed result back to model as function_call_output
                try {
                  if (callId){
                    dc.send(JSON.stringify({ type: 'conversation.item.create', item: { type: 'function_call_output', call_id: callId, output: JSON.stringify(result) } }));
                    dc.send(JSON.stringify({ type: 'response.create' }));
                  } else {
                    dc.send(JSON.stringify({ type: 'conversation.item.create', item: { type: 'message', role: 'user', content: [ { type: 'input_text', text } ] } }));
                    dc.send(JSON.stringify({ type: 'response.create' }));
                  }
                } catch (e) { console.error('feed result failed', e); }
              })
              .catch(err => {
                var label = humanTool(name);
                const text = `${label}: ${err.message}`;
                window.__chatAddMessage(text, 'user');
                try { window.__appendToolLog && window.__appendToolLog({ name, args, status: 'error', error: err.message }); } catch(_){ }
                try {
                  if (callId){
                    dc.send(JSON.stringify({ type: 'conversation.item.create', item: { type: 'function_call_output', call_id: callId, output: JSON.stringify({ error: err.message }) } }));
                    dc.send(JSON.stringify({ type: 'response.create' }));
                  } else {
                    dc.send(JSON.stringify({ type: 'conversation.item.create', item: { type: 'message', role: 'user', content: [ { type: 'input_text', text } ] } }));
                    dc.send(JSON.stringify({ type: 'response.create' }));
                  }
                } catch(_){}
              });
          } catch (e){ console.error('tool call parse/exec failed', e); }
          break;
        }
        default:
          break;
      }
    }

    async function startSession(){
      try {
        startBtn.disabled = true; setStatus('Connecting…');
        const tokenResp = await fetch('/token', { headers: { Authorization: 'Bearer ' + token }});
        if (!tokenResp.ok){ throw new Error('Failed to fetch token'); }
        const data = await tokenResp.json();
        const EPHEMERAL_KEY = data && (data.value || data.client_secret || data.token || data.key);
        if (!EPHEMERAL_KEY){ throw new Error('No ephemeral key returned'); }

        pc = new RTCPeerConnection();
        pc.ontrack = (e) => { audioEl.srcObject = e.streams[0]; };
        // Old initiation flow: acquire mic, attach track, but start muted
        ms = await navigator.mediaDevices.getUserMedia({ audio: true });
        var track = ms.getTracks()[0];
        track.enabled = false; // default muted
        sender = pc.addTrack(track);

        dc = pc.createDataChannel('oai-events');
        dc.addEventListener('open', () => {
          console.log('DataChannel open');
          // Show input only after session is ready
          var form = document.getElementById('chat-form');
          if (form) { form.style.display = 'flex'; }
          inputEl.disabled = false; sendBtn.disabled = false;
          registerTools();
          // Kick off an initial assistant response
          try {
            dc.send(JSON.stringify({ type: 'response.create' }));
          } catch (e) { console.warn('initial response.create failed', e); }
        });
        dc.addEventListener('message', (e) => {
          try { handleServerEvent(JSON.parse(e.data)); } catch(_) { console.log('Server raw:', e.data); }
        });

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        const baseUrl = 'https://api.openai.com/v1/realtime/calls';
        const model = 'gpt-realtime';
        const sdpResponse = await fetch(`${baseUrl}?model=${model}`, {
          method: 'POST',
          body: offer.sdp,
          headers: { Authorization: `Bearer ${EPHEMERAL_KEY}`, 'Content-Type': 'application/sdp' },
        });
        if (!sdpResponse.ok){
          const errText = await sdpResponse.text().catch(()=> '');
          throw new Error(`SDP exchange failed (${sdpResponse.status}): ${errText.slice(0,200)}`);
        }
        const answer = { type: 'answer', sdp: await sdpResponse.text() };
        await pc.setRemoteDescription(answer);

        startOverlay.style.display = 'none';
        var help = document.getElementById('chat-help'); if (help) help.style.display = 'none';
        document.getElementById('chat-toolbar').style.display = 'flex';
        setMutedUI(true);
        setStatus('Ready');
      } catch (err){
        console.error(err);
        alert('Voice session failed: ' + err.message);
        startBtn.disabled = false; setStatus('');
      }
    }

    async function toggleMic(){
      try {
        if (!ms){ return; }
        var t = ms.getTracks()[0];
        if (!t) return;
        t.enabled = !t.enabled;
        setMutedUI(!t.enabled);
      } catch (e){ console.error('toggle mic failed', e); }
    }

    startBtn.addEventListener('click', startSession);
    micToggle.addEventListener('click', toggleMic);

    async function sendText(){
      var text = (inputEl.value || '').trim();
      if (!text) return;
      if (!dc || dc.readyState !== 'open'){ alert('Session not connected. Press Start.'); return; }
      window.__chatAddMessage(text, 'user');
      inputEl.value = '';
      try {
        dc.send(JSON.stringify({
          type: 'conversation.item.create',
          item: { type: 'message', role: 'user', content: [ { type: 'input_text', text } ] }
        }));
        dc.send(JSON.stringify({ type: 'response.create' }));
      } catch (e){ console.error('send failed', e); }
    }
    async function sendPrompt(text){
      text = (text || '').trim();
      if (!text) return;
      if (!dc || dc.readyState !== 'open'){ alert('Session not connected. Press Start.'); return; }
      window.__chatAddMessage(text, 'user');
      try {
        dc.send(JSON.stringify({
          type: 'conversation.item.create',
          item: { type: 'message', role: 'user', content: [ { type: 'input_text', text } ] }
        }));
        dc.send(JSON.stringify({ type: 'response.create' }));
      } catch (e){ console.error('send failed', e); }
    }
    sendBtn.addEventListener('click', sendText);
    inputEl.addEventListener('keydown', function(e){ if (e.key === 'Enter') sendText(); });
  })();
</script>

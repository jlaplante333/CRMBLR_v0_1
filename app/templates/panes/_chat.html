<section class="pane split-left">
  <div class="pane-body">
    <div class="chat">
      <div id="start-overlay" style="display:flex; align-items:center; justify-content:center; height: 200px; border:1px dashed var(--border); border-radius:12px; margin-bottom:12px">
        <button id="btn-start" type="button" class="btn" style="font-weight:600; padding:12px 18px">Start</button>
      </div>

      <div class="flex start center" style="gap:8px; margin-bottom:12px">
        <button id="btn-upload" type="button" class="btn btn--secondary btn--icon">
          
          <span>Upload</span>
        </button>
        <form id="simple-upload-form"
              hx-post="/ui/ingest_batch_simple"
              hx-target="#modal-root"
              hx-swap="innerHTML"
              hx-encoding="multipart/form-data"
              enctype="multipart/form-data"
              style="display:none">
          <input id="simple-upload-input" type="file" name="files" accept=".csv" multiple />
        </form>
      </div>
      <div id="modal-root"></div>

      <div id="chat-help" style="margin-bottom:12px; color: var(--muted); font-size: 14px">
        <strong>How to use CRMBLR</strong>
        <div style="margin-top:6px">
          - Click Start to connect voice and tools.<br />
          - Type or speak your request (e.g., “find invoices from July”).<br />
          - The right panel shows tool calls and results.<br />
          - You can mute/unmute the mic anytime.
        </div>
      </div>

      <div id="chat-toolbar" style="display:none; align-items:center; gap:8px; margin-bottom:8px">
        <span id="audio-state" style="font-size:12px; color:var(--muted)">Muted</span>
        <button id="btn-mic-toggle" type="button" class="btn btn--secondary btn--icon btn--sm" aria-pressed="false">
          <svg class="icon" aria-hidden="true"><use href="/static/icons.svg#mic-off"></use></svg>
          <span>Unmute</span>
        </button>
        <button id="btn-session-toggle" type="button" class="btn btn--primary btn--icon btn--sm" style="display:none">
          <svg class="icon" aria-hidden="true"><use href="/static/icons.svg#pause"></use></svg>
          <span>Pause</span>
        </button>
        <span id="voice-status" style="margin-left:auto; color: var(--muted); font-size:12px"></span>
      </div>

      <!-- Input fixed at the top of the chat; hidden until session starts -->
      <form id="chat-form" class="chat-input" onsubmit="return false" style="display:none">
        <input id="chat-input" class="input" type="text" placeholder="Type a message…" autocomplete="off" aria-label="Chat input" disabled />
        <button id="chat-send" class="btn btn--primary btn--icon" type="button" disabled>
          <svg class="icon" aria-hidden="true"><use href="/static/icons.svg#send"></use></svg>
          <span>Send</span>
        </button>
      </form>

      <!-- Model-suggested Quick Actions (rendered as subtle chips) -->
      <div id="quick-actions" class="quick-actions" style="display:none; margin: 6px 0 10px; gap:6px; flex-wrap: wrap"></div>

      <!-- Newest messages appear at the top -->
      <ul id="chat-messages" class="chat-messages"></ul>

      <audio id="oai-audio" autoplay></audio>
    </div>
  </div>
</section>

<script>
  (function(){
    var list = document.getElementById('chat-messages');
    function addMessage(text, who, id){
      if (!list) return null;
      var li = document.createElement('li');
      li.className = 'chat-msg ' + (who || 'user');
      if (id) li.dataset.itemId = id;
      li.textContent = text;
      // Insert newest at the top
      if (list.firstChild) {
        list.insertBefore(li, list.firstChild);
      } else {
        list.appendChild(li);
      }
      return li;
    }
    window.__chatAddMessage = addMessage;
  })();
</script>

<script>
  (function(){
    // Upload button opens file picker; on select, auto-submit via HTMX
    try {
      var btn = document.getElementById('btn-upload');
      var form = document.getElementById('simple-upload-form');
      var input = document.getElementById('simple-upload-input');
      if (btn && form && input) {
        btn.addEventListener('click', function(){ input.click(); });
        input.addEventListener('change', function(){
          if (input.files && input.files.length) {
            if (window.htmx) {
              window.htmx.trigger(form, 'submit');
            } else {
              form.submit();
            }
          }
        });
      }
    } catch(_){}
    var startOverlay = document.getElementById('start-overlay');
    var startBtn = document.getElementById('btn-start');
    var micToggle = document.getElementById('btn-mic-toggle');
    var audioState = document.getElementById('audio-state');
    var statusEl = document.getElementById('voice-status');
    var audioEl = document.getElementById('oai-audio');
    var pc = null; var dc = null; var ms = null; var sender = null;
    var inputEl = document.getElementById('chat-input');
    var sendBtn = document.getElementById('chat-send');
    var sessionBtn = document.getElementById('btn-session-toggle');
    var qaEl = document.getElementById('quick-actions');
    var token = localStorage.getItem('crmb_lr_jwt');
    if (!token){ window.location.href = '/login'; return; }

    var assistantItems = Object.create(null); // assistant item_id -> <li>
    var assistantRaw = Object.create(null);   // assistant item_id -> raw text buffer (un-sanitized)
    var assistantHadDelta = Object.create(null); // assistant item_id -> saw any delta chunks
    var userItems = Object.create(null); // user item_id -> <li>
    var userText = Object.create(null); // user item_id -> transcript buffer

    function setStatus(t){ statusEl.textContent = t || ''; }

    function setMutedUI(isMuted){
      audioState.textContent = isMuted ? 'Muted' : 'Live';
      micToggle.setAttribute('aria-pressed', isMuted ? 'false' : 'true');
      // Update button classes only
      micToggle.className = 'btn ' + (isMuted ? 'btn--secondary' : 'btn--danger') + ' btn--icon btn--sm';
      // Update icon and label in-place (avoid rebuilding DOM)
      try {
        var use = micToggle.querySelector('use');
        if (use) { use.setAttribute('href', isMuted ? '/static/icons.svg#mic-off' : '/static/icons.svg#mic'); }
        var label = micToggle.querySelector('span');
        if (label) { label.textContent = isMuted ? 'Unmute' : 'Mute'; }
      } catch(_){}
    }
    // Legacy mic indicator hooks (no visible indicator in UI)
    function micOn(){ try { setMutedUI(false); } catch(_){} }
    function micOff(){ try { setMutedUI(true); } catch(_){} }

    const toolArgBuf = Object.create(null); // tool_call_id -> string buffer
    const toolMetaByItem = Object.create(null); // item_id -> { name, call_id }
    var lastAssistantId = null;

    function setQuickActions(actions){
      try {
        if (!qaEl) return;
        qaEl.innerHTML = '';
        if (!actions || !actions.length){ qaEl.style.display = 'none'; return; }
        actions.slice(0,4).forEach(function(text){
          var btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'btn btn--ghost btn--sm qa-chip';
          btn.textContent = text.length > 60 ? (text.slice(0,57) + '…') : text;
          btn.title = text;
          btn.addEventListener('click', function(){ sendPrompt(text); btn.disabled = true; setTimeout(function(){ btn.disabled = false; }, 600); });
          qaEl.appendChild(btn);
        });
        qaEl.style.display = 'flex';
      } catch(_){}
    }

    function parsePrompts(text){
      var out = [];
      try {
        var rx = /<<PROMPT:\s*(.*?)>>/g;
        var m;
        var seen = Object.create(null);
        while ((m = rx.exec(text))) {
          var s = (m[1] || '').trim();
          if (!s) continue;
          var key = s.toLowerCase();
          if (seen[key]) continue;
          seen[key] = true;
          out.push(s);
          if (out.length >= 4) break;
        }
      } catch(_){}
      return out;
    }

    function stripPrompts(text){
      try { return (text || '').replace(/<<PROMPT:[\s\S]*?>>/g, '').trim(); } catch(_) { return text; }
    }

    // For streaming display: as soon as we see '<<', hide everything after it
    function sanitizeForDisplay(raw){
      try {
        var s = String(raw || '');
        var i = s.indexOf('<<');
        return i >= 0 ? s.slice(0, i).trimEnd() : s;
      } catch(_) { return raw; }
    }

    function humanTool(name){
      var map = {
        list_collections: 'List Collections',
        list_docs: 'List Documents',
        search_docs: 'Search Documents',
        create_doc: 'Create Document',
        get_doc: 'Get Document',
        update_doc: 'Update Document',
        delete_doc: 'Delete Document'
      };
      if (!name) return 'Tool';
      return map[name] || String(name).replace(/_/g, ' ').replace(/\b\w/g, function(c){ return c.toUpperCase(); });
    }

    function registerTools(){
      if (!dc) return;
      const tools = [
        {
          type: "function",
          name: "list_collections",
          description: "List collection names for the current user",
          parameters: { type: "object", properties: {} }
        },
        {
          type: "function",
          name: "list_docs",
          description: "List documents in a collection",
          parameters: {
            type: "object",
            properties: {
              collection: { type: "string" },
              query: { type: "object" },
              size: { type: "integer", minimum: 1, default: 50 },
              from: { type: "integer", minimum: 0, default: 0 }
            },
            required: ["collection"],
            additionalProperties: true
          }
        },
        {
          type: "function",
          name: "search_docs",
          description: "Search documents across collections with conditions",
          parameters: {
            type: "object",
            properties: {
              collections: { type: "array", items: { type: "string" } },
              collection: { type: "string" },
              q: { type: "string" },
              where: { type: "object" },
              size: { type: "integer", minimum: 1, default: 50 },
              from: { type: "integer", minimum: 0, default: 0 },
              sort: { type: "array", items: { type: "object" } },
              fields: { type: "array", items: { type: "string" } },
              aggs: { type: "object" },
              highlight: { type: "object" }
            },
            additionalProperties: true
          }
        },
        {
          type: "function",
          name: "create_doc",
          description: "Create a document in an Elasticsearch index",
          parameters: {
            type: "object",
            properties: {
              collection: { type: "string" },
              doc: { type: "object" }
            },
            required: ["collection", "doc"],
            additionalProperties: true
          }
        },
        {
          type: "function",
          name: "get_doc",
          description: "Get a document by id",
          parameters: {
            type: "object",
            properties: {
              collection: { type: "string" },
              id: { type: "string" }
            },
            required: ["collection", "id"]
          }
        },
        {
          type: "function",
          name: "update_doc",
          description: "Update a document by id (merge fields)",
          parameters: {
            type: "object",
            properties: {
              collection: { type: "string" },
              id: { type: "string" },
              doc: { type: "object" }
            },
            required: ["collection", "id", "doc"],
            additionalProperties: true
          }
        },
        {
          type: "function",
          name: "delete_doc",
          description: "Delete a document by id",
          parameters: {
            type: "object",
            properties: {
              collection: { type: "string" },
              id: { type: "string" }
            },
            required: ["collection", "id"]
          }
        }
      ];
      try {
        dc.send(JSON.stringify({ type: 'session.update', session: { tools, tool_choice: 'auto' } }));
      } catch (e) { console.warn('Failed to register tools', e); }
    }

    async function callBackendTool(name, args){
      // Log start
      try { window.__appendToolLog && window.__appendToolLog({ name, args, status: 'started' }); } catch(_){ }
      const r = await fetch('/tool', { method:'POST', headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token }, body: JSON.stringify({ name, arguments: args }) });
      const data = await r.json();
      if (!r.ok || !data.ok){ throw new Error(data.error || 'tool error'); }
      try { window.__appendToolLog && window.__appendToolLog({ name, args, status: 'ok', result: data.result }); } catch(_){ }
      return data.result;
    }

    function handleServerEvent(obj){
      console.log('Server event:', obj);
      switch (obj.type){
        case 'error': {
          try { window.__appendToolLog && window.__appendToolLog({ name: 'error', status: 'error', error: JSON.stringify(obj.error || obj) }); } catch(_){ }
          break;
        }
        case 'session.created':
          setStatus('Connected');
          break;
        case 'input_audio_buffer.speech_started': {
          var li = window.__chatAddMessage('Listening…', 'user');
          userItems[obj.item_id] = li;
          micOn();
          break;
        }
        case 'input_audio_buffer.speech_stopped': {
          var li2 = userItems[obj.item_id];
          if (li2){ li2.textContent = 'Audio received'; }
          micOff();
          break;
        }
        case 'input_audio_buffer.committed': {
          var lu = userItems[obj.item_id];
          if (lu){ lu.textContent = 'Audio received'; }
          micOff();
          break;
        }
        case 'input_audio_buffer.transcript.delta': {
          var current = userText[obj.item_id] || '';
          var d = obj.delta || obj.transcript || '';
          current += d;
          userText[obj.item_id] = current;
          var lu = userItems[obj.item_id] || window.__chatAddMessage('', 'user');
          userItems[obj.item_id] = lu;
          lu.textContent = current;
          break;
        }
        case 'input_audio_buffer.transcript.done': {
          if (obj.transcript){ userText[obj.item_id] = obj.transcript; }
          var lu2 = userItems[obj.item_id];
          if (lu2 && userText[obj.item_id]){ lu2.textContent = userText[obj.item_id]; }
          micOff();
          break;
        }
        case 'conversation.item.added': {
          var it = obj.item || {};
          if (it.role === 'user'){
            var id = it.id || obj.item_id;
            // If a pending anonymous user bubble exists (typed send), adopt it
            var pending = document.querySelector('.chat-msg.user[data-pending-user="1"]');
            if (pending){ pending.dataset.itemId = id; pending.removeAttribute('data-pending-user'); userItems[id] = pending; }
            var lu3 = userItems[id] || window.__chatAddMessage('', 'user', id);
            userItems[id] = lu3;
            var t = userText[id];
            if (t && (!lu3.textContent || lu3.textContent === 'Listening…' || lu3.textContent === 'Audio received')){
              lu3.textContent = t;
            }
          } else if (it.role === 'assistant'){
            var aid = it.id || obj.item_id;
            var la = assistantItems[aid] || window.__chatAddMessage('', 'bot', aid);
            assistantItems[aid] = la;
            lastAssistantId = aid;
          }
          break;
        }
        case 'response.output_item.added': {
          var item = obj.item || {}; // sometimes included
          if (item.type === 'function_call'){
            toolMetaByItem[item.id] = { name: item.name, call_id: item.call_id };
            try { window.__appendToolLog && window.__appendToolLog({ name: item.name || 'function', status: 'started', args: {} }); } catch(_){ }
          } else {
            var id = (item && item.id) || obj.item_id;
            var li3 = assistantItems[id] || window.__chatAddMessage('', 'bot', id);
            assistantItems[id] = li3;
          }
          break;
        }
        case 'response.output_audio_transcript.delta': {
          var t = obj.delta || obj.transcript || '';
          var id = obj.item_id;
          assistantRaw[id] = (assistantRaw[id] || '') + t;
          assistantHadDelta[id] = true;
          var target = assistantItems[id];
          if (target){ target.textContent = sanitizeForDisplay(assistantRaw[id]); lastAssistantId = id; }
          break;
        }
        case 'response.output_audio_transcript.done': {
          var id = obj.item_id;
          if (!assistantHadDelta[id]){
            // No deltas were seen; use the final transcript as the buffer
            if (obj.transcript){ assistantRaw[id] = obj.transcript; }
          }
          var target2 = assistantItems[id];
          if (target2){ target2.textContent = sanitizeForDisplay(assistantRaw[id]); lastAssistantId = id; }
          break;
        }
        case 'response.output_text.delta': {
          var t2 = obj.delta || obj.text || '';
          var id2 = obj.item_id;
          assistantRaw[id2] = (assistantRaw[id2] || '') + t2;
          assistantHadDelta[id2] = true;
          var el2 = assistantItems[id2];
          if (el2){ el2.textContent = sanitizeForDisplay(assistantRaw[id2]); lastAssistantId = id2; }
          break;
        }
        case 'response.output_text.done': {
          var id3 = obj.item_id;
          if (!assistantHadDelta[id3]){
            var full = obj.text || obj.output_text || '';
            if (full){ assistantRaw[id3] = full; }
          }
          var el3 = assistantItems[id3];
          if (el3){ el3.textContent = sanitizeForDisplay(assistantRaw[id3]); lastAssistantId = id3; }
          break;
        }
        case 'response.content_part.done': {
          var p = obj.part || {};
          var id = obj.item_id;
          if (p){
            var text = '';
            if (typeof p.text === 'string') text = p.text;
            else if (typeof p.transcript === 'string') text = p.transcript;
            if (text){
              if (assistantHadDelta[id]){
                // We already built the buffer via deltas; avoid re-appending full text
              } else {
                assistantRaw[id] = text;
              }
              var target3 = assistantItems[id] || window.__chatAddMessage('', 'bot', id);
              target3.textContent = sanitizeForDisplay(assistantRaw[id]);
              assistantItems[id] = target3;
              lastAssistantId = id;
            }
          }
          break;
        }
        case 'response.done':
          try {
            var ids = Object.keys(assistantItems || {});
            var actionsSet = false;
            ids.forEach(function(aid){
              var el = assistantItems[aid]; if (!el) return;
              var raw = assistantRaw[aid] || el.textContent || '';
              var actions = parsePrompts(raw);
              var clean = stripPrompts(raw || '');
              el.textContent = sanitizeForDisplay(clean || '');
              // Assign quick actions from the last assistant id, or first with actions
              if (!actionsSet && actions && actions.length) {
                setQuickActions(actions);
                actionsSet = true;
              }
              assistantRaw[aid] = el.textContent;
              assistantHadDelta[aid] = false;
              // Remove empty assistant bubbles produced by duplicate events
              if (!el.textContent || !el.textContent.trim()){
                if (el.parentNode) el.parentNode.removeChild(el);
                delete assistantItems[aid];
              }
            });
          } catch(_){ }
          setStatus('Ready');
          break;
        // Tool calling (collect args, then execute)
        case 'response.function_call_arguments.delta': {
          const id = obj.item_id || obj.id || obj.call_id || 'default';
          const chunk = obj.delta || obj.arguments || '';
          toolArgBuf[id] = (toolArgBuf[id] || '') + chunk;
          break;
        }
        case 'response.function_call_arguments.done': {
          try {
            const id = obj.item_id || obj.id || obj.call_id || 'default';
            const meta = toolMetaByItem[id] || {};
            const name = meta.name || obj.name || obj.tool_name;
            const callId = meta.call_id || obj.call_id;
            const argsStr = toolArgBuf[id] || obj.arguments || '{}';
            const args = JSON.parse(argsStr || '{}');
            callBackendTool(name, args)
              .then(result => {
                // Hint only in chat instead of dumping full JSON
                var label = humanTool(name);
                var hint = `Ran ${label}`;
                try {
                  if (name === 'list_docs'){
                    var total = (result && result.hits && result.hits.total && (result.hits.total.value || result.hits.total)) || 0;
                    hint = `${label}: ${total} result${Number(total) === 1 ? '' : 's'}`;
                  } else if (name === 'list_collections'){
                    var cols = (result && result.collections) || [];
                    hint = `${label}: ${cols.length} found`;
                  }
                } catch(_){ }
                window.__chatAddMessage(hint, 'user');
                // Feed result back to model as function_call_output
                try {
                  if (callId){
                    dc.send(JSON.stringify({ type: 'conversation.item.create', item: { type: 'function_call_output', call_id: callId, output: JSON.stringify(result) } }));
                    dc.send(JSON.stringify({ type: 'response.create' }));
                  } else {
                    dc.send(JSON.stringify({ type: 'conversation.item.create', item: { type: 'message', role: 'user', content: [ { type: 'input_text', text } ] } }));
                    dc.send(JSON.stringify({ type: 'response.create' }));
                  }
                } catch (e) { console.error('feed result failed', e); }
              })
              .catch(err => {
                var label = humanTool(name);
                const text = `${label}: ${err.message}`;
                window.__chatAddMessage(text, 'user');
                try { window.__appendToolLog && window.__appendToolLog({ name, args, status: 'error', error: err.message }); } catch(_){ }
                try {
                  if (callId){
                    dc.send(JSON.stringify({ type: 'conversation.item.create', item: { type: 'function_call_output', call_id: callId, output: JSON.stringify({ error: err.message }) } }));
                    dc.send(JSON.stringify({ type: 'response.create' }));
                  } else {
                    dc.send(JSON.stringify({ type: 'conversation.item.create', item: { type: 'message', role: 'user', content: [ { type: 'input_text', text } ] } }));
                    dc.send(JSON.stringify({ type: 'response.create' }));
                  }
                } catch(_){}
              });
          } catch (e){ console.error('tool call parse/exec failed', e); }
          break;
        }
        default:
          break;
      }
    }

    async function startSession(){
      try {
        startBtn.disabled = true; setStatus('Connecting…');
        const tokenResp = await fetch('/token', { headers: { Authorization: 'Bearer ' + token }});
        if (!tokenResp.ok){ throw new Error('Failed to fetch token'); }
        const data = await tokenResp.json();
        const EPHEMERAL_KEY = data && (data.value || data.client_secret || data.token || data.key);
        if (!EPHEMERAL_KEY){ throw new Error('No ephemeral key returned'); }

        pc = new RTCPeerConnection();
        pc.ontrack = (e) => { audioEl.srcObject = e.streams[0]; };
        // Old initiation flow: acquire mic, attach track, but start muted
        ms = await navigator.mediaDevices.getUserMedia({ audio: true });
        var track = ms.getTracks()[0];
        track.enabled = false; // default muted
        sender = pc.addTrack(track);

        dc = pc.createDataChannel('oai-events');
        dc.addEventListener('open', () => {
          console.log('DataChannel open');
          // Show input only after session is ready
          var form = document.getElementById('chat-form');
          if (form) { form.style.display = 'flex'; }
          inputEl.disabled = false; sendBtn.disabled = false;
          if (sessionBtn) { sessionBtn.style.display = 'inline-flex'; }
          registerTools();
          // Kick off an initial assistant response
          try {
            dc.send(JSON.stringify({ type: 'response.create' }));
          } catch (e) { console.warn('initial response.create failed', e); }
        });
        dc.addEventListener('message', (e) => {
          try { handleServerEvent(JSON.parse(e.data)); } catch(_) { console.log('Server raw:', e.data); }
        });

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        const baseUrl = 'https://api.openai.com/v1/realtime/calls';
        const model = 'gpt-realtime';
        const sdpResponse = await fetch(`${baseUrl}?model=${model}`, {
          method: 'POST',
          body: offer.sdp,
          headers: { Authorization: `Bearer ${EPHEMERAL_KEY}`, 'Content-Type': 'application/sdp' },
        });
        if (!sdpResponse.ok){
          const errText = await sdpResponse.text().catch(()=> '');
          throw new Error(`SDP exchange failed (${sdpResponse.status}): ${errText.slice(0,200)}`);
        }
        const answer = { type: 'answer', sdp: await sdpResponse.text() };
        await pc.setRemoteDescription(answer);

        startOverlay.style.display = 'none';
        var help = document.getElementById('chat-help'); if (help) help.style.display = 'none';
        document.getElementById('chat-toolbar').style.display = 'flex';
        setMutedUI(true);
        setStatus('Ready');
      } catch (err){
        console.error(err);
        alert('Voice session failed: ' + err.message);
        startBtn.disabled = false; setStatus('');
      }
    }

    async function toggleMic(){
      try {
        if (!ms){ return; }
        var t = ms.getTracks()[0];
        if (!t) return;
        t.enabled = !t.enabled;
        setMutedUI(!t.enabled);
      } catch (e){ console.error('toggle mic failed', e); }
    }

    startBtn.addEventListener('click', startSession);
    micToggle.addEventListener('click', toggleMic);

    function teardownSession(){
      try { if (dc) { dc.close(); } } catch(_){}
      try { if (pc) { pc.close(); } } catch(_){}
      dc = null; pc = null; sender = null;
      if (ms){ try { ms.getTracks().forEach(t => { t.enabled = false; }); } catch(_){} }
      inputEl.disabled = true; sendBtn.disabled = true;
      setMutedUI(true);
      setStatus('Paused');
    }
    function markSessionPausedUI(paused){
      try {
        var use = sessionBtn && sessionBtn.querySelector('use');
        var label = sessionBtn && sessionBtn.querySelector('span');
        if (sessionBtn){ sessionBtn.className = 'btn btn--primary btn--icon btn--sm'; }
        if (use){ use.setAttribute('href', paused ? '/static/icons.svg#play' : '/static/icons.svg#pause'); }
        if (label){ label.textContent = paused ? 'Resume' : 'Pause'; }
      } catch(_){}
    }
    async function toggleSession(){
      if (dc && dc.readyState === 'open'){ teardownSession(); markSessionPausedUI(true); return; }
      // Resume: reconnect without showing the overlay
      try { await startSession(); markSessionPausedUI(false); } catch(_){}
    }
    if (sessionBtn){ sessionBtn.addEventListener('click', toggleSession); }

    async function sendText(){
      var text = (inputEl.value || '').trim();
      if (!text) return;
      if (!dc || dc.readyState !== 'open'){ alert('Session not connected. Press Start.'); return; }
      var anon = window.__chatAddMessage(text, 'user');
      try { anon.setAttribute('data-pending-user', '1'); } catch(_){ }
      inputEl.value = '';
      try {
        dc.send(JSON.stringify({
          type: 'conversation.item.create',
          item: { type: 'message', role: 'user', content: [ { type: 'input_text', text } ] }
        }));
        dc.send(JSON.stringify({ type: 'response.create' }));
      } catch (e){ console.error('send failed', e); }
    }
    async function sendPrompt(text){
      text = (text || '').trim();
      if (!text) return;
      if (!dc || dc.readyState !== 'open'){ alert('Session not connected. Press Start.'); return; }
      var anon = window.__chatAddMessage(text, 'user');
      try { anon.setAttribute('data-pending-user', '1'); } catch(_){ }
      try {
        dc.send(JSON.stringify({
          type: 'conversation.item.create',
          item: { type: 'message', role: 'user', content: [ { type: 'input_text', text } ] }
        }));
        dc.send(JSON.stringify({ type: 'response.create' }));
      } catch (e){ console.error('send failed', e); }
    }
    sendBtn.addEventListener('click', sendText);
    inputEl.addEventListener('keydown', function(e){ if (e.key === 'Enter') sendText(); });
  })();
</script>

<section class="pane split-left">
  <div class="pane-body">
    <div class="chat">
      <div id="start-overlay" style="display:flex; align-items:center; justify-content:center; height: 260px; border:1px dashed var(--border); border-radius:12px; margin-bottom:12px">
        <button id="btn-start" type="button" class="btn" style="font-weight:600; padding:12px 18px">Start</button>
      </div>

      <div id="chat-toolbar" style="display:none; align-items:center; gap:8px; margin-bottom:8px">
        <span id="audio-state" style="font-size:12px; color:var(--muted)">Muted</span>
        <button id="btn-mic-toggle" type="button" class="btn btn--secondary btn--sm">Unmute</button>
        <span id="voice-status" style="margin-left:auto; color: var(--muted); font-size:12px"></span>
      </div>

      <ul id="chat-messages" class="chat-messages"></ul>
      <form id="chat-form" class="chat-input" onsubmit="return false">
        <input id="chat-input" type="text" placeholder="Type a message…" autocomplete="off" aria-label="Chat input" disabled />
        <button id="chat-send" type="button" disabled>Send</button>
      </form>
      <audio id="oai-audio" autoplay></audio>
    </div>
  </div>
</section>

<script>
  (function(){
    var list = document.getElementById('chat-messages');
    function addMessage(text, who, id){
      if (!list) return null;
      var li = document.createElement('li');
      li.className = 'chat-msg ' + (who || 'user');
      if (id) li.dataset.itemId = id;
      li.textContent = text;
      list.appendChild(li);
      list.parentElement.scrollTop = list.parentElement.scrollHeight;
      return li;
    }
    window.__chatAddMessage = addMessage;
  })();
</script>

<script>
  (function(){
    var startOverlay = document.getElementById('start-overlay');
    var startBtn = document.getElementById('btn-start');
    var micToggle = document.getElementById('btn-mic-toggle');
    var audioState = document.getElementById('audio-state');
    var statusEl = document.getElementById('voice-status');
    var audioEl = document.getElementById('oai-audio');
    var pc = null; var dc = null; var ms = null; var sender = null;
    var inputEl = document.getElementById('chat-input');
    var sendBtn = document.getElementById('chat-send');
    var token = localStorage.getItem('crmb_lr_jwt');
    if (!token){ window.location.href = '/login'; return; }

    var assistantItems = Object.create(null); // assistant item_id -> <li>
    var userItems = Object.create(null); // user item_id -> <li>
    var userText = Object.create(null); // user item_id -> transcript buffer

    function setStatus(t){ statusEl.textContent = t || ''; }

    function setMutedUI(isMuted){
      audioState.textContent = isMuted ? 'Muted' : 'Unmuted';
      micToggle.textContent = isMuted ? 'Unmute' : 'Mute';
    }
    // Legacy mic indicator hooks (no visible indicator in UI)
    function micOn(){ try { setMutedUI(false); } catch(_){} }
    function micOff(){ try { setMutedUI(true); } catch(_){} }

    const toolArgBuf = Object.create(null); // tool_call_id -> string buffer
    const toolMetaByItem = Object.create(null); // item_id -> { name, call_id }

    function registerTools(){
      if (!dc) return;
      const tools = [
        {
          type: "function",
          name: "list_docs",
          description: "List documents in a collection",
          parameters: {
            type: "object",
            properties: {
              collection: { type: "string" },
              query: { type: "object" },
              size: { type: "integer", minimum: 1, default: 50 },
              from: { type: "integer", minimum: 0, default: 0 }
            },
            required: ["collection"],
            additionalProperties: true
          }
        },
        {
          type: "function",
          name: "create_doc",
          description: "Create a document in an Elasticsearch index",
          parameters: {
            type: "object",
            properties: {
              collection: { type: "string" },
              doc: { type: "object" }
            },
            required: ["collection", "doc"],
            additionalProperties: true
          }
        },
        {
          type: "function",
          name: "get_doc",
          description: "Get a document by id",
          parameters: {
            type: "object",
            properties: {
              collection: { type: "string" },
              id: { type: "string" }
            },
            required: ["collection", "id"]
          }
        },
        {
          type: "function",
          name: "update_doc",
          description: "Update a document by id (merge fields)",
          parameters: {
            type: "object",
            properties: {
              collection: { type: "string" },
              id: { type: "string" },
              doc: { type: "object" }
            },
            required: ["collection", "id", "doc"],
            additionalProperties: true
          }
        },
        {
          type: "function",
          name: "delete_doc",
          description: "Delete a document by id",
          parameters: {
            type: "object",
            properties: {
              collection: { type: "string" },
              id: { type: "string" }
            },
            required: ["collection", "id"]
          }
        }
      ];
      try {
        dc.send(JSON.stringify({ type: 'session.update', session: { tools, tool_choice: 'auto' } }));
      } catch (e) { console.warn('Failed to register tools', e); }
    }

    async function callBackendTool(name, args){
      // Log start
      try { window.__appendToolLog && window.__appendToolLog({ name, args, status: 'started' }); } catch(_){ }
      const r = await fetch('/tool', { method:'POST', headers: { 'Content-Type': 'application/json', Authorization: 'Bearer ' + token }, body: JSON.stringify({ name, arguments: args }) });
      const data = await r.json();
      if (!r.ok || !data.ok){ throw new Error(data.error || 'tool error'); }
      try { window.__appendToolLog && window.__appendToolLog({ name, args, status: 'ok', result: data.result }); } catch(_){ }
      return data.result;
    }

    function handleServerEvent(obj){
      console.log('Server event:', obj);
      switch (obj.type){
        case 'error': {
          try { window.__appendToolLog && window.__appendToolLog({ name: 'error', status: 'error', error: JSON.stringify(obj.error || obj) }); } catch(_){ }
          break;
        }
        case 'session.created':
          setStatus('Connected');
          break;
        case 'input_audio_buffer.speech_started': {
          var li = window.__chatAddMessage('Listening…', 'user');
          userItems[obj.item_id] = li;
          micOn();
          break;
        }
        case 'input_audio_buffer.speech_stopped': {
          var li2 = userItems[obj.item_id];
          if (li2){ li2.textContent = 'Audio received'; }
          micOff();
          break;
        }
        case 'input_audio_buffer.committed': {
          var lu = userItems[obj.item_id];
          if (lu){ lu.textContent = 'Audio received'; }
          micOff();
          break;
        }
        case 'input_audio_buffer.transcript.delta': {
          var current = userText[obj.item_id] || '';
          var d = obj.delta || obj.transcript || '';
          current += d;
          userText[obj.item_id] = current;
          var lu = userItems[obj.item_id] || window.__chatAddMessage('', 'user');
          userItems[obj.item_id] = lu;
          lu.textContent = current;
          break;
        }
        case 'input_audio_buffer.transcript.done': {
          if (obj.transcript){ userText[obj.item_id] = obj.transcript; }
          var lu2 = userItems[obj.item_id];
          if (lu2 && userText[obj.item_id]){ lu2.textContent = userText[obj.item_id]; }
          micOff();
          break;
        }
        case 'conversation.item.added': {
          var it = obj.item || {};
          if (it.role === 'user'){
            var id = it.id || obj.item_id;
            var lu3 = userItems[id] || window.__chatAddMessage('', 'user', id);
            userItems[id] = lu3;
            var t = userText[id];
            if (t && (!lu3.textContent || lu3.textContent === 'Listening…' || lu3.textContent === 'Audio received')){
              lu3.textContent = t;
            }
          } else if (it.role === 'assistant'){
            var aid = it.id || obj.item_id;
            var la = window.__chatAddMessage('', 'bot', aid);
            assistantItems[aid] = la;
          }
          break;
        }
        case 'response.output_item.added': {
          var item = obj.item || {}; // sometimes included
          if (item.type === 'function_call'){
            toolMetaByItem[item.id] = { name: item.name, call_id: item.call_id };
            try { window.__appendToolLog && window.__appendToolLog({ name: item.name || 'function', status: 'started', args: {} }); } catch(_){ }
          } else {
            var id = (item && item.id) || obj.item_id;
            var li3 = window.__chatAddMessage('', 'bot', id);
            assistantItems[id] = li3;
          }
          break;
        }
        case 'response.output_audio_transcript.delta': {
          var t = obj.delta || obj.transcript || '';
          var target = assistantItems[obj.item_id];
          if (target){ target.textContent += t; }
          break;
        }
        case 'response.output_audio_transcript.done': {
          var target2 = assistantItems[obj.item_id];
          if (target2 && obj.transcript){ target2.textContent = obj.transcript; }
          break;
        }
        case 'response.content_part.done': {
          var p = obj.part || {};
          if (p && p.transcript){
            var target3 = assistantItems[obj.item_id] || window.__chatAddMessage('', 'bot', obj.item_id);
            target3.textContent = p.transcript;
            assistantItems[obj.item_id] = target3;
          }
          break;
        }
        case 'response.done':
          setStatus('Ready');
          break;
        // Tool calling (collect args, then execute)
        case 'response.function_call_arguments.delta': {
          const id = obj.item_id || obj.id || obj.call_id || 'default';
          const chunk = obj.delta || obj.arguments || '';
          toolArgBuf[id] = (toolArgBuf[id] || '') + chunk;
          break;
        }
        case 'response.function_call_arguments.done': {
          try {
            const id = obj.item_id || obj.id || obj.call_id || 'default';
            const meta = toolMetaByItem[id] || {};
            const name = meta.name || obj.name || obj.tool_name;
            const callId = meta.call_id || obj.call_id;
            const argsStr = toolArgBuf[id] || obj.arguments || '{}';
            const args = JSON.parse(argsStr || '{}');
            callBackendTool(name, args)
              .then(result => {
                const text = `[${name}] success: ${JSON.stringify(result)}`;
                // Show in UI
                window.__chatAddMessage(text, 'user');
                // Feed result back to model as function_call_output
                try {
                  if (callId){
                    dc.send(JSON.stringify({ type: 'conversation.item.create', item: { type: 'function_call_output', call_id: callId, output: JSON.stringify(result) } }));
                    dc.send(JSON.stringify({ type: 'response.create' }));
                  } else {
                    dc.send(JSON.stringify({ type: 'conversation.item.create', item: { type: 'message', role: 'user', content: [ { type: 'input_text', text } ] } }));
                    dc.send(JSON.stringify({ type: 'response.create' }));
                  }
                } catch (e) { console.error('feed result failed', e); }
              })
              .catch(err => {
                const text = `[${name}] error: ${err.message}`;
                window.__chatAddMessage(text, 'user');
                try { window.__appendToolLog && window.__appendToolLog({ name, args, status: 'error', error: err.message }); } catch(_){ }
                try {
                  if (callId){
                    dc.send(JSON.stringify({ type: 'conversation.item.create', item: { type: 'function_call_output', call_id: callId, output: JSON.stringify({ error: err.message }) } }));
                    dc.send(JSON.stringify({ type: 'response.create' }));
                  } else {
                    dc.send(JSON.stringify({ type: 'conversation.item.create', item: { type: 'message', role: 'user', content: [ { type: 'input_text', text } ] } }));
                    dc.send(JSON.stringify({ type: 'response.create' }));
                  }
                } catch(_){}
              });
          } catch (e){ console.error('tool call parse/exec failed', e); }
          break;
        }
        default:
          break;
      }
    }

    async function startSession(){
      try {
        startBtn.disabled = true; setStatus('Connecting…');
        const tokenResp = await fetch('/token', { headers: { Authorization: 'Bearer ' + token }});
        if (!tokenResp.ok){ throw new Error('Failed to fetch token'); }
        const data = await tokenResp.json();
        const EPHEMERAL_KEY = data && (data.value || data.client_secret || data.token || data.key);
        if (!EPHEMERAL_KEY){ throw new Error('No ephemeral key returned'); }

        pc = new RTCPeerConnection();
        pc.ontrack = (e) => { audioEl.srcObject = e.streams[0]; };
        // Old initiation flow: acquire mic, attach track, but start muted
        ms = await navigator.mediaDevices.getUserMedia({ audio: true });
        var track = ms.getTracks()[0];
        track.enabled = false; // default muted
        sender = pc.addTrack(track);

        dc = pc.createDataChannel('oai-events');
        dc.addEventListener('open', () => {
          console.log('DataChannel open');
          inputEl.disabled = false; sendBtn.disabled = false;
          registerTools();
          // Kick off an initial assistant response
          try {
            dc.send(JSON.stringify({ type: 'response.create' }));
          } catch (e) { console.warn('initial response.create failed', e); }
        });
        dc.addEventListener('message', (e) => {
          try { handleServerEvent(JSON.parse(e.data)); } catch(_) { console.log('Server raw:', e.data); }
        });

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        const baseUrl = 'https://api.openai.com/v1/realtime/calls';
        const model = 'gpt-realtime';
        const sdpResponse = await fetch(`${baseUrl}?model=${model}`, {
          method: 'POST',
          body: offer.sdp,
          headers: { Authorization: `Bearer ${EPHEMERAL_KEY}`, 'Content-Type': 'application/sdp' },
        });
        if (!sdpResponse.ok){
          const errText = await sdpResponse.text().catch(()=> '');
          throw new Error(`SDP exchange failed (${sdpResponse.status}): ${errText.slice(0,200)}`);
        }
        const answer = { type: 'answer', sdp: await sdpResponse.text() };
        await pc.setRemoteDescription(answer);

        startOverlay.style.display = 'none';
        document.getElementById('chat-toolbar').style.display = 'flex';
        setMutedUI(true);
        setStatus('Ready');
      } catch (err){
        console.error(err);
        alert('Voice session failed: ' + err.message);
        startBtn.disabled = false; setStatus('');
      }
    }

    async function toggleMic(){
      try {
        if (!ms){ return; }
        var t = ms.getTracks()[0];
        if (!t) return;
        t.enabled = !t.enabled;
        setMutedUI(!t.enabled);
      } catch (e){ console.error('toggle mic failed', e); }
    }

    startBtn.addEventListener('click', startSession);
    micToggle.addEventListener('click', toggleMic);

    async function sendText(){
      var text = (inputEl.value || '').trim();
      if (!text) return;
      if (!dc || dc.readyState !== 'open'){ alert('Session not connected. Press Start.'); return; }
      window.__chatAddMessage(text, 'user');
      inputEl.value = '';
      try {
        dc.send(JSON.stringify({
          type: 'conversation.item.create',
          item: { type: 'message', role: 'user', content: [ { type: 'input_text', text } ] }
        }));
        dc.send(JSON.stringify({ type: 'response.create' }));
      } catch (e){ console.error('send failed', e); }
    }
    sendBtn.addEventListener('click', sendText);
    inputEl.addEventListener('keydown', function(e){ if (e.key === 'Enter') sendText(); });
  })();
</script>
